dispatch minecraft:resource[create:recipes] to struct Recipes {
	type: #[id] Type,
	...create:recipes[[type]],
}

enum(string) Type {
	Crushing = "create:crushing",
	Cutting = "create:cutting",
	Deploying = "create:deploying",
	Emptying = "create:emptying",
	Filling = "create:filling",
	Haunting = "create:haunting",
	ItemApplication = "create:item_application",
	MechanicalCrafting = "create:mechanical_crafting",
	Milling = "create:milling",
	Mixing = "create:mixing",
	Pressing = "create:pressing",
	SandpaperPolishing = "create:sandpaper_polishing",
	SequencedAssembly = "create:sequenced_assembly",
	Splashing = "create:splashing",
}

struct NBT {
	Bottle?: ("REGULAR" | "SPLASH" | "LINGERING"),
	Potion?: string,
}

struct Item {
	item?: string,
	tag?: string,
	fluid?: string,
	fluidTag?: string,
	amount?: int,
	nbt?: NBT
}

dispatch create:recipes[create:crushing] to struct {
	processingTime: int @ 1..,
	ingredients: [struct {
		item?: string,
		tag?: string,
	}] @ 1,
	results: [struct {
		chance?: float @ 0..,
		count?: int @ 1..,
		item: string,
	}] @ 1..,
}

dispatch create:recipes[create:cutting] to struct {
	processingTime: int @ 1..,
	ingredients: [struct {
		item?: string,
		tag?: string,
		count?: int @ 1..,
	}] @ 1,
	results: [struct {
		item: string,
		count?: int @ 1..,
	}] @ 1,
}

dispatch create:recipes[create:deploying] to struct {
	/// The first object is the base item and the second object is the ingredient
	ingredients: [struct {
		item?: string,
		tag?: string
	}] @ 2,
	keepHeldItem?: boolean,
	results: [struct {
		item: string,
	}] @ 1,
}

dispatch create:recipes[create:emptying] to struct {
	ingredients: [struct {
		item?: string,
		tag?: string,
	}] @ 1,
	results: [struct {
		item?: string,
		fluid?: string,
		amount?: int @ 1..,
	}],
}

dispatch create:recipes[create:filling] to struct {
	/// The first object is the base and the second object is the fluid
	ingredients: [struct {
		item?: string,
		tag?: string,
	}, struct {
		amount: int @ 1..,
		fluid?: string,
		fluidTag?: string,
		nbt: NBT,
	}],
	results: [struct { item: string }] @ 1,
}

dispatch create:recipes[create:haunting] to struct {
	ingredients: [struct {
		item?: string,
		tag?: string,
	}] @ 1,
	results: [struct {
		chance?: float @ 0..,
		count?: int @ 1..,
		item: string,
	}] @ 1..,
}

dispatch create:recipes[create:item_application] to struct {
	/// The first object is the base item and the second object is the ingredient
	ingredients: [struct {
		item?: string,
		tag?: string
	}] @ 2,
	results: [struct {
		item: string,
	}] @ 1,
}

dispatch create:recipes[create:mechanical_crafting] to MechanicalCrafting<string, string>

dispatch create:recipes[create:milling] to struct {
	processingTime: int @ 1..,
	ingredients: [struct {
		item?: string,
		tag?: string,
	}] @ 1,
	results: [struct {
		chance?: float @ 0..,
		count?: int @ 1..,
		item: string,
	}] @ 1..,
}

dispatch create:recipes[create:mixing] to struct {
	heatRequirement?: ("heated" | "superheated"),
	ingredients: [Item],
	results: [Item] @ 1,
}

dispatch create:recipes[create:pressing] to struct {
	ingredients: [struct {
		item?: string,
		tag?: string,
	}] @ 1,
	results: [struct {
		item?: string,
		tag?: string,
	}] @ 1,
}

dispatch create:recipes[create:sandpaper_polishing] to struct {
	ingredients: [struct {
		item?: string,
		tag?: string,
	}] @ 1,
	results: [struct {
		item?: string,
		tag?: string,
	}] @ 1,
}

dispatch create:recipes[create:sequenced_assembly] to struct {
	ingredient: struct {
		item?: string,
		tag?: string,
	},
	loops: int @ 1..,
	results: [struct {
		chance?: float @ 0..,
		count?: int @ 1..,
		item: string,
	}],
	sequence: [Recipes],
	transitionalItem: struct {
		item: string,
	},
}

dispatch create:recipes[create:splashing] to struct {
	ingredients: [struct {
		item?: string,
		tag?: string,
	}] @ 1,
	results: [struct {
		chance?: float @ 0..,
		count?: int @ 1..,
		item: string,
	}] @ 1..,
}

type MechanicalCrafting<K, V> = struct {
	acceptMirrored?: boolean,
	pattern: [string],
	key: struct {
		[K]: (V)
	},
	result: struct {
		count?: int @ 1..,
		item: string,
	},
}
